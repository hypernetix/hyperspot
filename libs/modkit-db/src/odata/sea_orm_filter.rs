//! Generic mapping from type-safe FilterNode<F> to SeaORM Conditions.
//!
//! This module provides the core logic for converting DTO-level filter expressions
//! into SeaORM conditions. Concrete modules only need to provide a mapping from
//! their DTO field enum to SeaORM Column types via the `FieldToColumn` trait.

use crate::odata::filter::{FilterField, FilterNode, FilterOp, ODataValue};
use crate::odata::{convert_expr_to_filter_node, FieldKind};
use bigdecimal::ToPrimitive;
use modkit_odata::{CursorV1, Error as ODataError, ODataOrderBy, Page, PageInfo, SortDir};
use sea_orm::{
    sea_query::{Expr, Order},
    Condition, ConnectionTrait, EntityTrait, QueryFilter, QueryOrder, QuerySelect,
};

/// Trait for mapping DTO filter fields to SeaORM columns.
///
/// This trait abstracts the mapping from a type-safe field enum (generated by
/// `#[derive(ODataFilterable)]`) to the corresponding SeaORM Column enum.
///
/// # Example
///
/// ```ignore
/// use modkit_db::odata::sea_orm_filter::FieldToColumn;
/// use crate::api::rest::dto::UserDtoFilterField;
/// use crate::testing::storage::entity::Column;
///
/// struct UserFieldMapper;
///
/// impl FieldToColumn<UserDtoFilterField> for UserFieldMapper {
///     type Column = Column;
///
///     fn map_field(field: UserDtoFilterField) -> Column {
///         match field {
///             UserDtoFilterField::Id => Column::Id,
///             UserDtoFilterField::Email => Column::Email,
///             UserDtoFilterField::CreatedAt => Column::CreatedAt,
///         }
///     }
/// }
/// ```
pub trait FieldToColumn<F: FilterField> {
    /// The SeaORM Column type for the entity
    type Column: Clone + sea_orm::Iden + sea_orm::ColumnTrait + sea_orm::IntoSimpleExpr + 'static;

    /// Map a DTO filter field to a SeaORM column
    fn map_field(field: F) -> Self::Column;
}

/// Extended trait for OData field mapping including cursor extraction.
///
/// This trait extends `FieldToColumn` with the ability to extract cursor values
/// from entity models, enabling type-safe pagination with ordering.
///
/// # Example
///
/// ```ignore
/// struct UserODataMapper;
///
/// impl FieldToColumn<UserDtoFilterField> for UserODataMapper {
///     type Column = Column;
///     fn map_field(field: UserDtoFilterField) -> Column { /* ... */ }
/// }
///
/// impl ODataFieldMapping<UserDtoFilterField> for UserODataMapper {
///     type Entity = Entity;
///     
///     fn extract_cursor_value(model: &Model, field: UserDtoFilterField) -> sea_orm::Value {
///         match field {
///             UserDtoFilterField::Id => sea_orm::Value::Uuid(Some(Box::new(model.id))),
///             UserDtoFilterField::Email => sea_orm::Value::String(Some(Box::new(model.email.clone()))),
///             UserDtoFilterField::CreatedAt => sea_orm::Value::ChronoDateTimeUtc(Some(Box::new(model.created_at))),
///         }
///     }
/// }
/// ```
pub trait ODataFieldMapping<F: FilterField>: FieldToColumn<F> {
    /// The SeaORM Entity type
    type Entity: EntityTrait;

    /// Extract a cursor value from a model for a specific field.
    ///
    /// This is used for cursor-based pagination to encode the values of
    /// ordering fields into the cursor.
    fn extract_cursor_value(
        model: &<Self::Entity as EntityTrait>::Model,
        field: F,
    ) -> sea_orm::Value;

    /// Extract cursor values for all fields in an order.
    ///
    /// This is a convenience method that can be overridden for optimization,
    /// but has a default implementation.
    fn extract_cursor_values(
        model: &<Self::Entity as EntityTrait>::Model,
        order: &ODataOrderBy,
    ) -> Result<Vec<(F, sea_orm::Value)>, String> {
        let mut values = Vec::new();
        for order_key in &order.0 {
            let field = F::from_name(&order_key.field)
                .ok_or_else(|| format!("Unknown orderby field: {}", order_key.field))?;
            let value = Self::extract_cursor_value(model, field);
            values.push((field, value));
        }
        Ok(values)
    }
}

/// Convert a FilterNode<F> to a SeaORM Condition using a FieldToColumn mapping.
///
/// This function provides generic traversal of the FilterNode AST and handles
/// all standard OData operations. Concrete modules only need to implement
/// `FieldToColumn` to map their DTO fields to database columns.
///
/// # Type Parameters
///
/// - `F`: The FilterField implementation (generated by `#[derive(ODataFilterable)]`)
/// - `M`: The FieldToColumn mapper that maps F to SeaORM columns
///
/// # Arguments
///
/// - `filter`: The type-safe filter node to convert
///
/// # Returns
///
/// A SeaORM Condition that can be applied to a query, or an error string if
/// the conversion fails.
///
/// # Example
///
/// ```ignore
/// let condition = filter_node_to_condition::<UserDtoFilterField, UserFieldMapper>(&filter)?;
/// let query = Entity::find().filter(condition);
/// ```
pub fn filter_node_to_condition<F, M>(filter: &FilterNode<F>) -> Result<Condition, String>
where
    F: FilterField,
    M: FieldToColumn<F>,
{
    match filter {
        FilterNode::Binary { field, op, value } => {
            // Map DTO field to database column
            let column = M::map_field(*field);
            build_binary_condition(column, *op, value)
        }
        FilterNode::Composite { op, children } => {
            // Combine child conditions with AND or OR
            let base = match op {
                FilterOp::And => Condition::all(),
                FilterOp::Or => Condition::any(),
                _ => return Err(format!("Invalid composite operator: {:?}", op)),
            };

            children.iter().try_fold(base, |acc, child| {
                let child_cond = filter_node_to_condition::<F, M>(child)?;
                Ok(acc.add(child_cond))
            })
        }
        FilterNode::Not(inner) => {
            // FIXED: Call .not() AFTER adding the inner condition
            let inner_cond = filter_node_to_condition::<F, M>(inner)?;
            Ok(Condition::all().add(inner_cond).not())
        }
    }
}

/// Build a binary condition (field op value) for SeaORM.
///
/// This handles all comparison and string function operations.
fn build_binary_condition<C>(
    column: C,
    op: FilterOp,
    value: &ODataValue,
) -> Result<Condition, String>
where
    C: sea_orm::Iden + sea_orm::ColumnTrait + sea_orm::IntoSimpleExpr + Clone + 'static,
{
    // Convert ODataValue to sea_orm::Value
    let sea_value = odata_value_to_sea_value(value)?;

    // Handle NULL specially
    if matches!(value, ODataValue::Null) {
        return Ok(match op {
            FilterOp::Eq => Condition::all().add(Expr::col(column).is_null()),
            FilterOp::Ne => Condition::all().add(Expr::col(column).is_not_null()),
            _ => return Err(format!("Unsupported operator for NULL: {:?}", op)),
        });
    }

    // Build the expression based on the operator
    let expr = match op {
        FilterOp::Eq => Expr::col(column).eq(sea_value),
        FilterOp::Ne => Expr::col(column).ne(sea_value),
        FilterOp::Gt => Expr::col(column).gt(sea_value),
        FilterOp::Ge => Expr::col(column).gte(sea_value),
        FilterOp::Lt => Expr::col(column).lt(sea_value),
        FilterOp::Le => Expr::col(column).lte(sea_value),
        FilterOp::Contains => {
            let s = extract_string(value)?;
            Expr::col(column).like(format!("%{}%", escape_like(&s)))
        }
        FilterOp::StartsWith => {
            let s = extract_string(value)?;
            Expr::col(column).like(format!("{}%", escape_like(&s)))
        }
        FilterOp::EndsWith => {
            let s = extract_string(value)?;
            Expr::col(column).like(format!("%{}", escape_like(&s)))
        }
        FilterOp::And | FilterOp::Or => {
            return Err(format!("Logical operator {:?} in binary context", op));
        }
    };

    Ok(Condition::all().add(expr))
}

/// Convert an ODataValue to a sea_orm::Value.
fn odata_value_to_sea_value(value: &ODataValue) -> Result<sea_orm::Value, String> {
    Ok(match value {
        ODataValue::String(s) => sea_orm::Value::String(Some(Box::new(s.clone()))),
        ODataValue::Number(n) => {
            // Try to convert to i64 first, then f64
            if let Some(i) = n.to_i64() {
                sea_orm::Value::BigInt(Some(i))
            } else if let Some(f) = n.to_f64() {
                sea_orm::Value::Double(Some(f))
            } else {
                return Err("Number value out of range".to_string());
            }
        }
        ODataValue::Bool(b) => sea_orm::Value::Bool(Some(*b)),
        ODataValue::Uuid(u) => sea_orm::Value::Uuid(Some(Box::new(*u))),
        ODataValue::DateTime(dt) => sea_orm::Value::ChronoDateTimeUtc(Some(Box::new(*dt))),
        ODataValue::Date(d) => sea_orm::Value::ChronoDate(Some(Box::new(*d))),
        ODataValue::Time(t) => sea_orm::Value::ChronoTime(Some(Box::new(*t))),
        ODataValue::Null => {
            return Err("NULL values should be handled separately".to_string());
        }
    })
}

/// Extract a string from an ODataValue.
fn extract_string(value: &ODataValue) -> Result<String, String> {
    match value {
        ODataValue::String(s) => Ok(s.clone()),
        _ => Err(format!("Expected string value, got {:?}", value)),
    }
}

/// Escape special characters in LIKE patterns.
///
/// This escapes `%`, `_`, and `\` to prevent them from being interpreted
/// as wildcards in SQL LIKE patterns.
pub fn escape_like(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    for ch in s.chars() {
        match ch {
            '%' | '_' | '\\' => {
                out.push('\\');
                out.push(ch);
            }
            c => out.push(c),
        }
    }
    out
}

/// Encode a sea_orm::Value to a string for cursor storage.
///
/// This converts SeaORM values to strings that can be embedded in cursors.
pub fn encode_cursor_value(value: &sea_orm::Value, kind: FieldKind) -> Result<String, String> {
    use sea_orm::Value as V;

    let result = match (kind, value) {
        (FieldKind::String, V::String(Some(s))) => s.to_string(),
        (FieldKind::I64, V::BigInt(Some(i))) => i.to_string(),
        (FieldKind::F64, V::Double(Some(f))) => ryu::Buffer::new().format(*f).to_string(),
        (FieldKind::Bool, V::Bool(Some(b))) => b.to_string(),
        (FieldKind::Uuid, V::Uuid(Some(u))) => u.to_string(),
        (FieldKind::DateTimeUtc, V::ChronoDateTimeUtc(Some(dt))) => dt.to_rfc3339(),
        (FieldKind::Date, V::ChronoDate(Some(d))) => d.to_string(),
        (FieldKind::Time, V::ChronoTime(Some(t))) => t.to_string(),
        (FieldKind::Decimal, V::Decimal(Some(d))) => d.to_string(),
        _ => return Err("Unsupported or mismatched cursor value type".to_string()),
    };

    Ok(result)
}

/// Parse a cursor value from string based on field kind
///
/// This is the inverse of `encode_cursor_value`, converting cursor strings
/// back to typed SeaORM values for comparison in queries.
pub fn parse_cursor_value(kind: FieldKind, s: &str) -> Result<sea_orm::Value, String> {
    use sea_orm::Value as V;

    let result = match kind {
        FieldKind::String => V::String(Some(Box::new(s.to_string()))),
        FieldKind::I64 => {
            let i = s
                .parse::<i64>()
                .map_err(|_| "invalid i64 in cursor".to_string())?;
            V::BigInt(Some(i))
        }
        FieldKind::F64 => {
            let f = s
                .parse::<f64>()
                .map_err(|_| "invalid f64 in cursor".to_string())?;
            V::Double(Some(f))
        }
        FieldKind::Bool => {
            let b = s
                .parse::<bool>()
                .map_err(|_| "invalid bool in cursor".to_string())?;
            V::Bool(Some(b))
        }
        FieldKind::Uuid => {
            let u = s
                .parse::<uuid::Uuid>()
                .map_err(|_| "invalid uuid in cursor".to_string())?;
            V::Uuid(Some(Box::new(u)))
        }
        FieldKind::DateTimeUtc => {
            let dt = chrono::DateTime::parse_from_rfc3339(s)
                .map_err(|_| "invalid datetime in cursor".to_string())?
                .with_timezone(&chrono::Utc);
            V::ChronoDateTimeUtc(Some(Box::new(dt)))
        }
        FieldKind::Date => {
            let d = s
                .parse::<chrono::NaiveDate>()
                .map_err(|_| "invalid date in cursor".to_string())?;
            V::ChronoDate(Some(Box::new(d)))
        }
        FieldKind::Time => {
            let t = s
                .parse::<chrono::NaiveTime>()
                .map_err(|_| "invalid time in cursor".to_string())?;
            V::ChronoTime(Some(Box::new(t)))
        }
        FieldKind::Decimal => {
            let d = s
                .parse::<rust_decimal::Decimal>()
                .map_err(|_| "invalid decimal in cursor".to_string())?;
            V::Decimal(Some(Box::new(d)))
        }
    };

    Ok(result)
}

/// Pagination limit configuration
#[derive(Clone, Copy)]
pub struct LimitCfg {
    pub default: u64,
    pub max: u64,
}

/// Clamp the requested limit to configured bounds
fn clamp_limit(req: Option<u64>, cfg: LimitCfg) -> Result<u64, ODataError> {
    let mut l = req.unwrap_or(cfg.default);
    if l == 0 {
        l = 1;
    }
    if l > cfg.max {
        l = cfg.max;
    }
    Ok(l)
}

/// Type-safe OData pagination with filters, ordering, and cursors.
///
/// This function provides complete cursor-based pagination using the type-safe
/// FilterField and ODataFieldMapping traits. It replaces the legacy FieldMap-based
/// pagination.
///
/// # Type Parameters
///
/// - `F`: FilterField implementation (generated by `#[derive(ODataFilterable)]`)
/// - `M`: ODataFieldMapping implementation that maps F to SeaORM columns and extracts cursor values
/// - `E`: SeaORM Entity type
/// - `D`: Domain/DTO type to map models to
/// - `Mapper`: Function to map Entity::Model to D
/// - `C`: Database connection type
///
/// # Arguments
///
/// - `select`: Base SeaORM select query (already security-scoped if needed)
/// - `conn`: Database connection
/// - `query`: OData query with filter, order, cursor, and limit
/// - `tiebreaker`: Default orderby field and direction for stable pagination
/// - `limit_cfg`: Default and maximum page sizes
/// - `model_to_domain`: Function to convert entity models to domain types
///
/// # Returns
///
/// A Page containing the results and pagination metadata (next/prev cursors)
///
/// # Example
///
/// ```ignore
/// let page = paginate_odata::<UserDtoFilterField, UserODataMapper, _, _, _, _>(
///     base_query,
///     db.conn(),
///     &odata_query,
///     ("id", SortDir::Desc),
///     LimitCfg { default: 25, max: 1000 },
///     |model| model.into(),
/// ).await?;
/// ```
pub async fn paginate_odata<F, M, E, D, Mapper, C>(
    select: sea_orm::Select<E>,
    conn: &C,
    query: &modkit_odata::ODataQuery,
    tiebreaker: (&str, SortDir),
    limit_cfg: LimitCfg,
    model_to_domain: Mapper,
) -> Result<Page<D>, ODataError>
where
    F: FilterField,
    M: ODataFieldMapping<F, Entity = E>,
    E: EntityTrait,
    Mapper: Fn(E::Model) -> D,
    C: ConnectionTrait + Send + Sync,
{
    let limit = clamp_limit(query.limit, limit_cfg)?;
    let fetch = limit + 1;

    // Effective order derivation
    let effective_order = if let Some(cur) = &query.cursor {
        ODataOrderBy::from_signed_tokens(&cur.s).map_err(|_| ODataError::InvalidCursor)?
    } else {
        query
            .order
            .clone()
            .ensure_tiebreaker(tiebreaker.0, tiebreaker.1)
    };

    // Validate cursor consistency (filter hash only)
    if let Some(cur) = &query.cursor {
        if let (Some(h), Some(cf)) = (query.filter_hash.as_deref(), cur.f.as_deref()) {
            if h != cf {
                return Err(ODataError::FilterMismatch);
            }
        }
    }

    let mut s = select;

    // Apply filter using type-safe FilterNode
    if let Some(ast) = query.filter.as_deref() {
        let filter_node = convert_expr_to_filter_node::<F>(ast)
            .map_err(|e| ODataError::InvalidFilter(e.to_string()))?;
        let cond =
            filter_node_to_condition::<F, M>(&filter_node).map_err(ODataError::InvalidFilter)?;
        s = s.filter(cond);
    }

    let is_backward = query.cursor.as_ref().map(|c| c.d == "bwd").unwrap_or(false);

    // Apply cursor predicate
    if let Some(cursor) = &query.cursor {
        let cond = build_cursor_predicate::<F, M>(cursor, &effective_order)?;
        s = s.filter(cond);
    }

    // Apply ordering
    let query_order = if is_backward {
        effective_order.clone().reverse_directions()
    } else {
        effective_order.clone()
    };

    for order_key in &query_order.0 {
        let field = F::from_name(&order_key.field)
            .ok_or_else(|| ODataError::InvalidOrderByField(order_key.field.clone()))?;
        let column = M::map_field(field);
        let sea_order = match order_key.dir {
            SortDir::Asc => Order::Asc,
            SortDir::Desc => Order::Desc,
        };
        s = s.order_by(column, sea_order);
    }

    s = s.limit(fetch);

    #[allow(clippy::disallowed_methods)]
    let mut rows = s
        .all(conn)
        .await
        .map_err(|e| ODataError::Db(e.to_string()))?;

    let has_more = (rows.len() as u64) > limit;

    // Handle backward pagination reversal
    if is_backward {
        if has_more {
            rows.pop();
        }
        rows.reverse();
    } else if has_more {
        rows.truncate(usize::try_from(limit).unwrap_or(usize::MAX));
    }

    // Build cursors
    let next_cursor = if is_backward || has_more {
        build_cursor_from_rows::<E, F, M>(
            &rows,
            &effective_order,
            query.filter_hash.as_deref(),
            "fwd",
            true,
        )?
    } else {
        None
    };

    let prev_cursor = if is_backward {
        if has_more {
            build_cursor_from_rows::<E, F, M>(
                &rows,
                &effective_order,
                query.filter_hash.as_deref(),
                "bwd",
                false,
            )?
        } else {
            None
        }
    } else if query.cursor.is_some() {
        build_cursor_from_rows::<E, F, M>(
            &rows,
            &effective_order,
            query.filter_hash.as_deref(),
            "bwd",
            false,
        )?
    } else {
        None
    };

    let items = rows.into_iter().map(model_to_domain).collect();

    Ok(Page {
        items,
        page_info: PageInfo {
            next_cursor,
            prev_cursor,
            limit,
        },
    })
}

/// Build a cursor from rows, using either the first or last row
fn build_cursor_from_rows<E, F, M: ODataFieldMapping<F, Entity = E>>(
    rows: &[<E as EntityTrait>::Model],
    effective_order: &ODataOrderBy,
    filter_hash: Option<&str>,
    direction: &str,
    use_last: bool,
) -> Result<Option<String>, ODataError>
where
    F: FilterField,
    E: EntityTrait,
{
    let row = if use_last { rows.last() } else { rows.first() };

    row.map(|m| build_cursor_from_model::<F, M>(m, effective_order, filter_hash, direction))
        .transpose()
        .and_then(|opt| match opt {
            Some(c) => c.encode().map(Some).map_err(|_| ODataError::InvalidCursor),
            None => Ok(None),
        })
}

/// Build a cursor predicate for pagination
fn build_cursor_predicate<F, M>(
    cursor: &CursorV1,
    order: &ODataOrderBy,
) -> Result<Condition, ODataError>
where
    F: FilterField,
    M: ODataFieldMapping<F>,
{
    if cursor.k.len() != order.0.len() {
        return Err(ODataError::InvalidCursor);
    }

    // Parse all cursor values first
    let mut cursor_values: Vec<(F, M::Column, sea_orm::Value, SortDir)> = Vec::new();
    for (i, key_str) in cursor.k.iter().enumerate() {
        let order_key = &order.0[i];
        let field = F::from_name(&order_key.field)
            .ok_or(ODataError::InvalidOrderByField(order_key.field.clone()))?;
        let column = M::map_field(field);
        let kind = field.kind();
        let value = parse_cursor_value(kind, key_str).map_err(|_| ODataError::InvalidCursor)?;
        cursor_values.push((field, column, value, order_key.dir));
    }

    let is_backward = cursor.d == "bwd";
    let mut main_condition = Condition::any();

    for i in 0..cursor_values.len() {
        let mut prefix_condition = Condition::all();

        // Add equality conditions for all previous fields
        for (_field, column, value, _dir) in cursor_values.iter().take(i) {
            prefix_condition = prefix_condition.add(Expr::col(*column).eq(value.clone()));
        }

        // Add comparison for current field
        let (_field, column, value, dir) = &cursor_values[i];
        let comparison = if is_backward {
            // Backward: reverse the comparison
            match dir {
                SortDir::Asc => Expr::col(*column).lt(value.clone()),
                SortDir::Desc => Expr::col(*column).gt(value.clone()),
            }
        } else {
            // Forward: normal comparison
            match dir {
                SortDir::Asc => Expr::col(*column).gt(value.clone()),
                SortDir::Desc => Expr::col(*column).lt(value.clone()),
            }
        };

        prefix_condition = prefix_condition.add(comparison);
        main_condition = main_condition.add(prefix_condition);
    }

    Ok(main_condition)
}

/// Build a cursor from an entity model
fn build_cursor_from_model<F, M>(
    model: &<M::Entity as EntityTrait>::Model,
    order: &ODataOrderBy,
    filter_hash: Option<&str>,
    direction: &str,
) -> Result<CursorV1, ODataError>
where
    F: FilterField,
    M: ODataFieldMapping<F>,
{
    let field_values =
        M::extract_cursor_values(model, order).map_err(|_e| ODataError::InvalidCursor)?;

    let mut cursor_keys = Vec::new();
    for (field, value) in field_values {
        let kind = field.kind();
        let key_str = encode_cursor_value(&value, kind).map_err(|_| ODataError::InvalidCursor)?;
        cursor_keys.push(key_str);
    }

    // Determine primary sort direction from first order key
    let primary_dir = order.0.first().map(|k| k.dir).unwrap_or(SortDir::Desc);

    Ok(CursorV1 {
        k: cursor_keys,
        o: primary_dir,
        s: order.to_signed_tokens(),
        f: filter_hash.map(|s| s.to_string()),
        d: direction.to_string(),
    })
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    #[test]
    fn test_escape_like() {
        assert_eq!(escape_like("test"), "test");
        assert_eq!(escape_like("test%"), "test\\%");
        assert_eq!(escape_like("test_name"), "test\\_name");
        assert_eq!(escape_like("test\\value"), "test\\\\value");
    }

    #[test]
    fn test_odata_value_to_sea_value_string() {
        let value = ODataValue::String("test".to_string());
        let result = odata_value_to_sea_value(&value);
        assert!(result.is_ok());
    }

    #[test]
    fn test_odata_value_to_sea_value_null() {
        let value = ODataValue::Null;
        let result = odata_value_to_sea_value(&value);
        assert!(result.is_err());
    }

    // Cursor value encoding/decoding tests
    #[test]
    fn test_encode_decode_cursor_string() {
        use sea_orm::Value as V;
        let val = V::String(Some(Box::new("test".to_string())));
        let encoded = encode_cursor_value(&val, FieldKind::String).unwrap();
        assert_eq!(encoded, "test");

        let decoded = parse_cursor_value(FieldKind::String, &encoded).unwrap();
        assert!(matches!(decoded, V::String(Some(_))));
    }

    #[test]
    fn test_encode_decode_cursor_i64() {
        use sea_orm::Value as V;
        let val = V::BigInt(Some(42));
        let encoded = encode_cursor_value(&val, FieldKind::I64).unwrap();
        assert_eq!(encoded, "42");

        let decoded = parse_cursor_value(FieldKind::I64, &encoded).unwrap();
        assert!(matches!(decoded, V::BigInt(Some(42))));
    }

    #[test]
    fn test_encode_decode_cursor_f64() {
        use sea_orm::Value as V;
        let val = V::Double(Some(3.5));
        let encoded = encode_cursor_value(&val, FieldKind::F64).unwrap();

        let decoded = parse_cursor_value(FieldKind::F64, &encoded).unwrap();
        if let V::Double(Some(f)) = decoded {
            assert!((f - 3.5).abs() < 0.001);
        } else {
            panic!("Expected Double value");
        }
    }

    #[test]
    fn test_encode_decode_cursor_bool() {
        use sea_orm::Value as V;
        let val = V::Bool(Some(true));
        let encoded = encode_cursor_value(&val, FieldKind::Bool).unwrap();
        assert_eq!(encoded, "true");

        let decoded = parse_cursor_value(FieldKind::Bool, &encoded).unwrap();
        assert!(matches!(decoded, V::Bool(Some(true))));
    }

    #[test]
    fn test_encode_decode_cursor_uuid() {
        use sea_orm::Value as V;
        let id = uuid::Uuid::new_v4();
        let val = V::Uuid(Some(Box::new(id)));
        let encoded = encode_cursor_value(&val, FieldKind::Uuid).unwrap();

        let decoded = parse_cursor_value(FieldKind::Uuid, &encoded).unwrap();
        if let V::Uuid(Some(decoded_id)) = decoded {
            assert_eq!(*decoded_id, id);
        } else {
            panic!("Expected UUID value");
        }
    }

    #[test]
    fn test_encode_decode_cursor_datetime() {
        use chrono::{TimeZone, Utc};
        use sea_orm::Value as V;

        let dt = Utc.with_ymd_and_hms(2024, 1, 15, 10, 30, 0).unwrap();
        let val = V::ChronoDateTimeUtc(Some(Box::new(dt)));
        let encoded = encode_cursor_value(&val, FieldKind::DateTimeUtc).unwrap();

        let decoded = parse_cursor_value(FieldKind::DateTimeUtc, &encoded).unwrap();
        if let V::ChronoDateTimeUtc(Some(decoded_dt)) = decoded {
            assert_eq!(*decoded_dt, dt);
        } else {
            panic!("Expected DateTime value");
        }
    }

    #[test]
    fn test_encode_decode_cursor_date() {
        use chrono::NaiveDate;
        use sea_orm::Value as V;

        let date = NaiveDate::from_ymd_opt(2024, 1, 15).unwrap();
        let val = V::ChronoDate(Some(Box::new(date)));
        let encoded = encode_cursor_value(&val, FieldKind::Date).unwrap();

        let decoded = parse_cursor_value(FieldKind::Date, &encoded).unwrap();
        if let V::ChronoDate(Some(decoded_date)) = decoded {
            assert_eq!(*decoded_date, date);
        } else {
            panic!("Expected Date value");
        }
    }

    #[test]
    fn test_encode_decode_cursor_time() {
        use chrono::NaiveTime;
        use sea_orm::Value as V;

        let time = NaiveTime::from_hms_opt(10, 30, 45).unwrap();
        let val = V::ChronoTime(Some(Box::new(time)));
        let encoded = encode_cursor_value(&val, FieldKind::Time).unwrap();

        let decoded = parse_cursor_value(FieldKind::Time, &encoded).unwrap();
        if let V::ChronoTime(Some(decoded_time)) = decoded {
            assert_eq!(*decoded_time, time);
        } else {
            panic!("Expected Time value");
        }
    }

    #[test]
    fn test_encode_decode_cursor_decimal() {
        use rust_decimal::Decimal;
        use sea_orm::Value as V;
        use std::str::FromStr;

        let dec = Decimal::from_str("19.99").unwrap();
        let val = V::Decimal(Some(Box::new(dec)));
        let encoded = encode_cursor_value(&val, FieldKind::Decimal).unwrap();

        let decoded = parse_cursor_value(FieldKind::Decimal, &encoded).unwrap();
        if let V::Decimal(Some(decoded_dec)) = decoded {
            assert_eq!(*decoded_dec, dec);
        } else {
            panic!("Expected Decimal value");
        }
    }

    #[test]
    fn test_parse_cursor_invalid_i64() {
        let result = parse_cursor_value(FieldKind::I64, "not-a-number");
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_cursor_invalid_uuid() {
        let result = parse_cursor_value(FieldKind::Uuid, "not-a-uuid");
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_cursor_invalid_bool() {
        let result = parse_cursor_value(FieldKind::Bool, "maybe");
        assert!(result.is_err());
    }

    // Note: filter_node_to_condition tests are covered by integration tests
    // in examples/modkit/users_info where we have full SeaORM entity setup.
    // Unit testing filter_node_to_condition requires mock Column types with
    // ColumnTrait implementation, which needs strum derives that are complex
    // to set up in a unit test context.
    //
    // The cursor encoding/decoding tests above provide good unit test coverage
    // of the core functionality in this module.
}
