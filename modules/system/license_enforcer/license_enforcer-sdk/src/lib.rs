//! License Enforcer SDK
//!
//! This crate provides the public API for the `license_enforcer` module:
//!
//! - [`LicenseEnforcerGatewayClient`] - Public API trait for consumers
//! - [`PlatformPluginClient`] - Platform request plugin API trait for implementations
//! - [`CachePluginClient`] - Cache plugin API trait for implementations
//! - Domain models for license enforcement
//! - [`LicenseEnforcerError`] - Error types
//! - GTS schemas for plugin discovery
//!
//! ## Usage
//!
//! Consumers obtain the client from `ClientHub`:
//!
//! ```
//! # use license_enforcer_sdk::{LicenseEnforcerGatewayClient, global_features};
//! # use modkit::client_hub::ClientHub;
//! # use modkit_security::SecurityContext;
//! # use std::sync::Arc;
//! # use uuid::Uuid;
//! # async fn example() -> Result<(), Box<dyn std::error::Error>> {
//! # let hub = Arc::new(ClientHub::new());
//! # let tenant_id = Uuid::new_v4();
//! # let ctx = SecurityContext::builder().tenant_id(tenant_id).subject_id(Uuid::new_v4()).build();
//! // Get the client from ClientHub
//! let enforcer = hub.get::<dyn LicenseEnforcerGatewayClient>()?;
//!
//! // Check license access
//! let feature = global_features::BaseFeature;
//! let is_enabled = enforcer.is_global_feature_enabled(&ctx, tenant_id, &feature).await?;
//! # Ok(())
//! # }
//! ```
#![forbid(unsafe_code)]
#![deny(rust_2018_idioms)]

pub mod api;
pub mod error;
pub mod gts_cache;
pub mod gts_platform;
pub mod models;
pub mod plugin_cache;
pub mod plugin_platform;

// Re-export main types at crate root
pub use api::LicenseEnforcerGatewayClient;
pub use error::LicenseEnforcerError;
pub use gts_cache::LicenseCachePluginSpecV1;
pub use gts_platform::LicensePlatformPluginSpecV1;
pub use models::{EnabledGlobalFeatures, global_features, parse_license_feature_id};
pub use plugin_cache::CachePluginClient;
pub use plugin_platform::PlatformPluginClient;

/// Returns all license feature GTS schemas for registration in Type Registry.
///
/// Includes:
/// - Base feature schema (`gts.x.core.lic.feat.v1~`)
/// - All global feature instances
///
/// # Example
///
/// ```no_run
/// use license_enforcer_sdk::get_feature_gts_schemas;
///
/// let schemas = get_feature_gts_schemas()?;
/// // Register schemas with Type Registry
/// // registry.register(schemas).await?;
/// # Ok::<(), license_enforcer_sdk::LicenseEnforcerError>(())
/// ```
///
/// # Errors
///
/// Returns an error if schema deserialization or feature serialization fails.
pub fn get_feature_gts_schemas() -> Result<Vec<serde_json::Value>, LicenseEnforcerError> {
    let mut schemas = Vec::with_capacity(5);

    // Add the base schema (type definition)
    let schema_str = models::LicenseFeatureIdSpecV1::gts_schema_with_refs_as_string();
    let schema_json: serde_json::Value = serde_json::from_str(&schema_str).map_err(|e| {
        LicenseEnforcerError::internal_with_source("Failed to deserialize feature schema JSON", e)
    })?;
    schemas.push(schema_json);

    // Add all global feature instances
    schemas.extend(get_global_feature_instances()?);

    Ok(schemas)
}

/// Returns all global feature instances as GTS entities.
///
/// Uses the existing `From<&Feature> for LicenseFeatureIdSpecV1` conversions
/// generated by the `global_feature!` macro.
///
/// # Example
///
/// ```no_run
/// use license_enforcer_sdk::get_global_feature_instances;
///
/// let instances = get_global_feature_instances()?;
/// for instance in instances {
///     println!("Feature: {}", instance.get("id").unwrap());
/// }
/// # Ok::<(), license_enforcer_sdk::LicenseEnforcerError>(())
/// ```
///
/// # Errors
///
/// Returns an error if feature serialization fails.
pub fn get_global_feature_instances() -> Result<Vec<serde_json::Value>, LicenseEnforcerError> {
    use global_features::{
        BaseFeature, CyberChatFeature, CyberEmployeeAgentsFeature, CyberEmployeeUnitsFeature,
    };
    use models::LicenseFeatureIdSpecV1;

    // Convert each feature using the existing From impl, then serialize
    let features = vec![
        (
            "BaseFeature",
            serde_json::to_value(LicenseFeatureIdSpecV1::from(&BaseFeature)),
        ),
        (
            "CyberChatFeature",
            serde_json::to_value(LicenseFeatureIdSpecV1::from(&CyberChatFeature)),
        ),
        (
            "CyberEmployeeAgentsFeature",
            serde_json::to_value(LicenseFeatureIdSpecV1::from(&CyberEmployeeAgentsFeature)),
        ),
        (
            "CyberEmployeeUnitsFeature",
            serde_json::to_value(LicenseFeatureIdSpecV1::from(&CyberEmployeeUnitsFeature)),
        ),
    ];

    let mut result = Vec::with_capacity(features.len());
    for (name, value_result) in features {
        let value = value_result.map_err(|e| {
            LicenseEnforcerError::internal_with_source(format!("Failed to serialize {name}"), e)
        })?;
        result.push(value);
    }

    Ok(result)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_feature_gts_schemas_returns_schema_and_instances() {
        let schemas = get_feature_gts_schemas().expect("Should not fail");

        // Should contain base schema + 4 global features
        assert_eq!(
            schemas.len(),
            5,
            "Expected 5 schemas (1 type + 4 instances)"
        );

        // First should be the base schema (type)
        let base_schema = &schemas[0];
        assert!(
            base_schema.get("$id").is_some() || base_schema.get("gtsId").is_some(),
            "Base schema should have $id or gtsId field"
        );
    }

    #[test]
    fn test_get_global_feature_instances_returns_all_features() {
        let instances = get_global_feature_instances().expect("Should not fail");

        assert_eq!(instances.len(), 4, "Should have 4 global features");

        // Verify each instance has required fields
        for instance in &instances {
            assert!(
                instance.get("id").is_some(),
                "Instance must have 'id' field"
            );
            assert!(
                instance.get("is_global").is_some(),
                "Instance must have 'is_global' field"
            );
            assert!(
                instance.get("description").is_some(),
                "Instance must have 'description' field"
            );
        }
    }

    #[test]
    fn test_feature_instance_ids_follow_gts_format() {
        let instances = get_global_feature_instances().expect("Should not fail");

        for instance in instances {
            let id = instance.get("id").unwrap().as_str().unwrap();

            // Must start with the feature schema ID prefix
            assert!(
                id.starts_with("gts.x.core.lic.feat.v1~"),
                "Feature ID '{id}' must start with schema prefix"
            );

            // Must have instance portion after tilde
            let parts: Vec<&str> = id.splitn(2, '~').collect();
            assert_eq!(parts.len(), 2, "Feature ID must have type~instance format");
            assert!(!parts[1].is_empty(), "Instance portion must not be empty");
        }
    }

    #[test]
    fn test_all_features_are_global() {
        let instances = get_global_feature_instances().expect("Should not fail");

        for instance in instances {
            assert!(
                instance.get("is_global").unwrap().as_bool().unwrap(),
                "All global features must have is_global=true"
            );
        }
    }

    #[test]
    fn test_base_feature_from_conversion() {
        use global_features::BaseFeature;
        use models::LicenseFeatureIdSpecV1;

        let spec = LicenseFeatureIdSpecV1::from(&BaseFeature);
        let json = serde_json::to_value(&spec).unwrap();

        assert_eq!(
            json.get("id").unwrap().as_str().unwrap(),
            "gts.x.core.lic.feat.v1~x.core.global.base.v1"
        );
        assert!(json.get("is_global").unwrap().as_bool().unwrap());
        assert!(
            json.get("description")
                .unwrap()
                .as_str()
                .unwrap()
                .contains("Base feature")
        );
    }

    #[test]
    fn test_feature_id_roundtrip_parsing() {
        let instances = get_global_feature_instances().expect("Should not fail");

        for instance in instances {
            let id_str = instance.get("id").unwrap().as_str().unwrap();

            // Should be parseable back to a feature ID
            let parsed = parse_license_feature_id(id_str);
            assert!(parsed.is_ok(), "Entity ID '{id_str}' should be parseable");
        }
    }
}
