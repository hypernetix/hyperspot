# AI Agent Instructions for Hyperspot

<!-- 
⚠️ AI AGENT NOTICE: This file was generated by workflow adapter-config-from-code.
If user wants to modify this adapter, run workflow adapter-config again or edit manually with caution.
Manual edits may be overwritten if workflow is re-run.
-->

**Extends**: `../FDD/AGENTS.md`

**Discovery Method**: Code analysis
<!-- Discovered from /Volumes/CaseSensitive/coding/hyperspot on 2026-01-06 -->

---

## Project Context

**Purpose**: Hyperspot Server - Modular application platform with extensible plugin architecture using GTS type system

**Technology Stack**:
- **Language**: Rust (edition 2021)
- **Web Framework**: Axum 0.8
- **gRPC**: Tonic 0.14 + Protocol Buffers
- **Database**: SQLx 0.8, SeaORM 1.1 (PostgreSQL, SQLite)
- **Runtime**: Tokio 1.47
- **Type System**: GTS (Global Type System) v0.7.6
- **Authentication**: JWT, OAuth/OIDC
- **Observability**: OpenTelemetry, tracing

---

## Core Methodology

**READ FIRST**: `guidelines/FDD/AGENTS.md`

**CRITICAL**: Follow all rules in `guidelines/FDD/AGENTS.md` - they are immutable and validated by tooling.

---

## Domain Model

**Technology**: GTS (Global Type System) + JSON Schema

**Specification**: `guidelines/GTS`

**⚠️ CRITICAL**: Before using GTS, read the specification at `guidelines/GTS/README.md`

**⚠️ GTS IDENTIFIER RULES** (STRICTLY ENFORCED):
- ALL segments MUST be lowercase (a-z, 0-9, underscore only)
- NO uppercase letters allowed in identifiers
- Format: `gts.vendor.package.namespace.type.v<MAJOR>[.<MINOR>]`
- Type names: use snake_case (e.g., `user_profile`, NOT `UserProfile`)
- Example: `gts.ainetx.hyperspot.users.user_profile.v1` ✅
- Invalid: `gts.ainetx.hyperspot.users.UserProfile.v1` ❌

**Location**: Distributed across modules following modkit architecture
- Type definitions: `modules/*/src/domain/`
- Type registry: `modules/types-registry/`
- Schema validation: Via GTS library and JSON Schema

**DML Syntax**: Use GTS reference format in JSON Schema `$ref` fields:
- Schema $id: `gts.vendor.package.namespace.type.v<version>`
- Schema $ref: `gts://gts.vendor.package.namespace.type.v<version>`
- All identifiers MUST be lowercase with underscores for word separation

**Validation**: 
```bash
# Validate JSON schemas per JSON Schema draft-07 specification
# Verify GTS identifiers follow lowercase-only format
cargo test --package types-registry --lib
cargo run --package types-registry -- validate
```

**Architecture Pattern**: Modkit system with strict layer separation:
- **Contract layer** (`-contracts`, `-sdk`): Pure domain types, GTS structs, no HTTP/serde
- **Domain layer**: Business logic, services
- **API layer** (`api/rest/`, `api/grpc/`): DTOs with serde, HTTP types allowed
- **Infra layer**: Database, external integrations

---

## API Contracts

**Technology**: Hybrid - OpenAPI 3.x (REST) + gRPC Protocol Buffers

**OpenAPI Specification**:
- **Format**: OpenAPI 3.x via utoipa macros
- **Generation**: Automatic via utoipa annotations
- **Location**: `docs/api/api.json`
- **Runtime endpoint**: `http://localhost:8087/openapi.json`

**gRPC Specification**:
- **Format**: Protocol Buffers (.proto files)
- **Location**: `proto/`
- **Code generation**: Via tonic-build in build.rs

**API Location**: 
- REST: `modules/*/src/api/rest/`
- gRPC: `modules/*/src/api/grpc/`

**Validation**:
```bash
# Validate OpenAPI spec (design-time)
openapi-spec-validator modules/*/architecture/openapi/v1/api.yaml

# Validate OpenAPI spec (runtime)
make openapi-fetch  # Fetches from running server
openapi-spec-validator docs/api/api.json

# gRPC validation happens at compile time via tonic-build
```

**Installation**:
```bash
# Install OpenAPI validator
pip install openapi-spec-validator

# Or via requirements.txt
echo "openapi-spec-validator>=0.7.1" >> testing/requirements.txt
```

---

## Technical Architecture (Section C)

### Security Model

JWT-based authentication with multi-provider support (Keycloak, generic OIDC). Role-based access control with GTS-based permission system. Per-module authorization via plugin architecture. mTLS support for gRPC inter-module communication.

### Non-Functional Requirements

- **Performance**: API response < 200ms, async-first architecture with Tokio runtime
- **Modularity**: Plugin-based architecture with isolated modules, hot-reloadable configurations
- **Observability**: Structured logging with tracing, OpenTelemetry integration, distributed tracing
- **Database**: SQLx for type-safe queries, SeaORM for complex operations, migration support
- **Safety**: Strict linting (100+ clippy deny rules), custom architectural lints (dylint), forbidden unsafe code
- **Testing**: Comprehensive test coverage with testcontainers for integration tests
- **Scalability**: Stateless design, horizontal scaling ready, async I/O throughout
- **Type Safety**: GTS-based type system for cross-module type validation and extensibility

---

## Platform Helpers & Reusable Components

**⚠️ CRITICAL FOR OPENSPEC**: When generating changes, implementing features, or validating code, ALWAYS check if these platform helpers can be reused instead of reimplementing functionality.

### GTS (Global Type System) - `gts` crate v0.7.6

**Purpose**: Type system for cross-module type validation and extensibility

**Key Components**:
- **`GtsID::new(gts_id: &str)`**: Parse and validate GTS identifiers
  - Returns: `Result<GtsID, GtsError>` with parsed segments
  - Usage: `let parsed = GtsID::new("gts.vendor.pkg.ns.type.v1~instance.v1")?;`
  - Access segments: `parsed.gts_id_segments: Vec<GtsIdSegment>`
- **`GtsIdSegment`**: Individual segments of GTS identifier
- **`GtsOps`**: Operations on GTS entities (CRUD, query)
- **`GtsConfig`**: Configuration for GTS system
- **`GtsWildcard`**: Wildcard matching for GTS patterns
- **`gts_macros::struct_to_gts_schema`**: Convert Rust structs to GTS schemas

**Location**: External dependency from https://github.com/globaltypesystem/gts-rust.git

**When to Use**: ANY work with GTS identifiers, type parsing, schema generation

**Example Usage**:
```rust
use gts::{GtsID, GtsIdSegment};

// Parse identifier and extract type
let parsed = GtsID::new(gts_id).map_err(|e| DomainError::invalid_gts_id(e.to_string()))?;
let segments: Vec<GtsIdSegment> = parsed.gts_id_segments.clone();
let is_schema = gts_id.ends_with('~');
```

### ModKit - `modkit` crate

**Purpose**: Declarative module system with lifecycle management, API building, and telemetry

**Key Components**:

**Module System**:
- **`#[module(...)]`**: Declarative module registration macro
- **`ModuleRegistry`**: Auto-discovery and module management
- **`ClientHub`**: Service discovery and inter-module communication
- **`Lifecycle`**: Phase-based lifecycle (init, configure, ready, run, shutdown)

**API Building**:
- **`OperationBuilder`**: Type-safe REST API operation builder with OpenAPI generation
  - Methods: `get()`, `post()`, `put()`, `patch()`, `delete()`
  - OpenAPI: `.summary()`, `.json_response()`, `.standard_errors()`
  - Middleware: `.to_layer()` converts to Axum layer
- **`OpenApiRegistry`**: Automatic OpenAPI spec aggregation
- **`Problem`**: RFC 7807 Problem Details error responses
  - Helpers: `bad_request()`, `not_found()`, `internal_error()`, `conflict()`
- **`ValidationError`**: Structured validation errors

**HTTP Utilities**:
- **`TracedClient`**: HTTP client with distributed tracing
- **`SseBroadcaster`**: Server-Sent Events broadcasting

**Pagination**:
- **`Page<T>`**: Generic pagination wrapper
- **`PageInfo`**: Pagination metadata

**When to Use**: 
- Module registration and lifecycle
- Building REST APIs with automatic OpenAPI generation
- HTTP clients with tracing
- Error handling and problem details
- Pagination

**Example Usage**:
```rust
use modkit::{OperationBuilder, Problem, bad_request};

let op = OperationBuilder::get("/api/v1/users")
    .summary("List users")
    .handler(list_users)
    .json_response(200, "List of users")
    .standard_errors(&registry);

async fn list_users() -> Result<Json<Vec<User>>, Problem> {
    // Implementation
}
```

### ModKit Auth - `modkit-auth` crate

**Purpose**: JWT validation, authentication, and authorization

**Key Components**:
- **`AuthDispatcher`**: Multi-provider JWT validation (Keycloak, OIDC)
- **`Claims`**: Parsed JWT claims with tenant/user context
- **`TokenValidator`**: Trait for custom validators
- **`AuthModeConfig`**: Plugin-based auth configuration
- **`axum_ext`**: Axum middleware for JWT extraction (feature-gated)

**When to Use**: JWT validation, SecurityCtx creation, multi-tenant auth

**Example Usage**:
```rust
use modkit_auth::{AuthDispatcher, Claims};

let dispatcher = AuthDispatcher::new(config);
let claims: Claims = dispatcher.validate_token(&token).await?;
let tenant_id = claims.tenant_id();
let user_id = claims.user_id();
```

### ModKit OData - `modkit-odata` crate

**Purpose**: OData v4 query parameter parsing and pagination

**Key Components**:
- **`ODataLimits`**: Query limits validation
- **`Page<T>`**: OData-compatible pagination response
- **`PageInfo`**: OData pagination metadata (@odata.nextLink, @odata.count)
- **`normalize_filter_for_hash()`**: Normalize $filter for caching
- **`short_filter_hash()`**: Generate short hash for $filter expressions
- **`ast::Expr`**: OData filter AST (And, Or, Compare, In, Function, etc.)
- **`CompareOperator`**: Eq, Ne, Gt, Ge, Lt, Le
- **`ODataOrderBy`**: $orderby parsing and handling
- **`SortDir`**: Asc/Desc with `.reverse()`

**When to Use**: 
- OData $filter, $orderby, $top, $skiptoken parsing
- Query optimization and validation
- Cursor-based pagination
- Filter expression caching

**Example Usage**:
```rust
use modkit_odata::{Page, PageInfo, ODataLimits};

let limits = ODataLimits::default();
let page = Page {
    items: vec![...],
    info: PageInfo {
        next_link: Some("..."),
        count: Some(100),
    },
};
```

### ModKit Security - `modkit-security` crate

**Purpose**: Security context, permissions, and access control

**Key Components**:
- **`SecurityCtx`**: Security context with tenant/user/permissions
- **`Permission`**: GTS-based permission system
- **`AccessScope`**: Scope-based access control
- **`Subject`**: Security subject (user, service, etc.)
- **`bin_codec`**: Binary encoding/decoding for security tokens

**When to Use**: Tenant isolation, permission checks, security context propagation

**Example Usage**:
```rust
use modkit_security::{SecurityCtx, Permission};

let ctx = SecurityCtx::new(tenant_id, user_id, permissions);
if ctx.has_permission(&Permission::write("users"))? {
    // Authorized
}
```

### ModKit DB - `modkit-db` crate

**Purpose**: Database connection management, OData query building, and secure ORM

**Key Components**:
- **`DbPool`**: Connection pool management (PostgreSQL, SQLite)
- **`DbOptions`**: Database configuration
- **`odata/`**: OData query builder for SQL
- **`secure/`**: Tenant-isolated database operations
- **`advisory_locks`**: PostgreSQL advisory locks
- **`Manager`**: Database lifecycle management

**When to Use**: 
- Database connections
- OData $filter → SQL translation
- Tenant-isolated queries
- Migration management

**Example Usage**:
```rust
use modkit_db::DbPool;

let pool = DbPool::connect(&config).await?;
let conn = pool.acquire().await?;
```

### Types Registry - `types-registry` module

**Purpose**: GTS type registration and querying

**Key Components**:
- **`InMemoryGtsRepository`**: In-memory GTS entity storage
- **`GtsRepository` trait**: Repository abstraction
- **`TypesRegistryService`**: Business logic for type management
- **GTS Operations**: Register, query, list, validate types

**Location**: `modules/types-registry/`

**When to Use**: Type registration, GTS schema validation, type discovery

---

## Helper Selection Guidelines

**When implementing a feature**:

1. **Check GTS needs** → Use `gts` crate (`GtsID::new()`, `GtsOps`)
2. **Check API needs** → Use `modkit::OperationBuilder`, `Problem`
3. **Check auth needs** → Use `modkit-auth::AuthDispatcher`, `Claims`
4. **Check OData needs** → Use `modkit-odata` for pagination, filtering
5. **Check security needs** → Use `modkit-security::SecurityCtx`, `Permission`
6. **Check DB needs** → Use `modkit-db::DbPool`, OData query builder

**DO NOT reimplement**:
- ❌ GTS identifier parsing (use `GtsID::new()`)
- ❌ JWT validation (use `AuthDispatcher`)
- ❌ Problem Details errors (use `Problem`, `bad_request()`, etc.)
- ❌ OData pagination (use `Page`, `PageInfo`)
- ❌ Security context (use `SecurityCtx`)
- ❌ OpenAPI generation (use `OperationBuilder`)

**OpenSpec Change Generation**:
- When generating `tasks.md`, reference existing helpers
- When generating delta specs, mention required helpers from platform
- When implementing, import and use platform helpers instead of writing new code

---

## References

- **Core FDD**: `guidelines/FDD/AGENTS.md`
- **Workflows**: `guidelines/FDD/workflows/`
- **FDL Syntax**: `guidelines/FDD/FDL.md`
- **Adapter Guide**: `guidelines/FDD/ADAPTER_GUIDE.md`
- **GTS Specification**: `guidelines/GTS/README.md`
- **Architecture**: `docs/ARCHITECTURE_MANIFEST.md`
- **Modkit System**: `docs/MODKIT_UNIFIED_SYSTEM.md`
- **Platform Helpers**: `libs/modkit*/src/lib.rs` (this section)
