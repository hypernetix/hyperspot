# GTS Error System Documentation

This document describes how errors are defined, structured, transformed, and used in the Hyperspot/gts-rust project.

## Overview

The error system follows **RFC 9457 Problem Details for HTTP APIs** and uses a **GTS (Global Type System)** format for error codes. The system provides:

- **Compile-time validated** error catalogs via JSON files
- **Type-safe** error code enums generated by proc-macros
- **Layered error transformation** from domain → API → HTTP response
- **Consistent error format** across all modules

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Error Flow                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  gts/errors.json  ──────►  declare_errors! macro  ──────►  ErrorCode    │
│  (Source of Truth)         (Compile-time)                  (Enum)       │
│                                                                          │
│  DomainError  ──────►  ErrorCode::xxx().with_context()  ──────►  Problem│
│  (Business Logic)      (Mapping Layer)                        (RFC 9457)│
│                                                                          │
│  Problem  ──────►  IntoResponse (Axum)  ──────►  HTTP Response          │
│  (Data)            (Framework Integration)       (JSON + Headers)       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Components

### 1. Error Catalog JSON (`gts/errors.json`)

The source of truth for error definitions. Located in each module's `gts/` directory.

**File Location Pattern:** `<module>/gts/errors.json`

**Schema:**
```json
[
  {
    "status": 404,
    "title": "User Not Found",
    "code": "gts.hx.core.errors.err.v1~hx.example1.user.not_found.v1",
    "type": "https://errors.example.com/...",  // optional
    "alias": "user_not_found"                   // optional
  }
]
```

**Fields:**
| Field | Required | Description |
|-------|----------|-------------|
| `status` | Yes | HTTP status code (100-599) |
| `title` | Yes | Human-readable error title |
| `code` | Yes | GTS-formatted error code |
| `type` | No | URI for error documentation |
| `alias` | No | Short name override for generated accessor |

### 2. GTS Code Format

GTS codes follow a strict format for global type identification:

```
gts.vendor.package.namespace.type.version~chain1~chain2~...~instanceGTX
```

**Structure:**
- **Prefix:** Always starts with `gts.`
- **Chain separator:** `~` separates GTX segments
- **Segment separator:** `.` separates parts within a GTX
- **Final GTX:** Must have at least 5 segments: `vendor.package.namespace.type.version`
- **Version:** Must end with `vN` or `vN.M` format

**Example Breakdown:**
```
gts.hx.core.errors.err.v1~hx.example1.user.not_found.v1
│   │  │    │      │   │  │  │        │    │         │
│   │  │    │      │   │  │  │        │    │         └─ version
│   │  │    │      │   │  │  │        │    └─ type (not_found)
│   │  │    │      │   │  │  │        └─ namespace (user)
│   │  │    │      │   │  │  └─ package (example1)
│   │  │    │      │   │  └─ vendor (hx)
│   │  │    │      │   └─ version
│   │  │    │      └─ type (err)
│   │  │    └─ namespace (errors)
│   │  └─ package (core)
│   └─ vendor (hx)
└─ prefix
```

**Validation Rules:**
1. Must start with `gts.`
2. All segments must be lowercase alphanumeric or underscore
3. No empty segments allowed
4. Final GTX must have ≥5 segments after vendor
5. Must end with valid version format (`v1`, `v1.2`, etc.)

### 3. Proc-Macro: `declare_errors!`

Generates type-safe error code enums from JSON at compile time.

**Location:** `libs/modkit-errors-macro/src/lib.rs`

**Usage:**
```rust
use modkit_errors_macro::declare_errors;

declare_errors! {
    path = "gts/errors.json",
    namespace = "errors",
    vis = "pub"
}
```

**Parameters:**
| Parameter | Required | Description |
|-----------|----------|-------------|
| `path` | Yes | Path to JSON file relative to `CARGO_MANIFEST_DIR` |
| `namespace` | Yes | Module name for generated code |
| `vis` | No | Visibility (`"pub"` or private) |

**Generated Code:**
```rust
// Enum with all error codes
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ErrorCode {
    gts_hx_core_errors_err_v1_hx_example1_user_not_found_v1,
    // ...
}

impl ErrorCode {
    // Get HTTP status
    pub const fn status(&self) -> u16 { ... }
    
    // Get full error definition
    pub const fn def(&self) -> ErrDef { ... }
    
    // Convert to Problem with detail
    pub fn as_problem(&self, detail: impl Into<String>) -> Problem { ... }
    
    // Create Problem with context (instance + trace_id)
    pub fn with_context(
        &self,
        detail: impl Into<String>,
        instance: &str,
        trace_id: Option<String>,
    ) -> Problem { ... }
    
    // Short accessor (derived from GTS or alias)
    pub const fn example1_user_not_found_v1() -> Self { ... }
}

// Compile-time validated macro
macro_rules! problem_from_catalog { ... }
macro_rules! response_from_catalog { ... }
```

### 4. Core Types

#### `ErrDef` (Error Definition)
**Location:** `libs/modkit-errors/src/catalog.rs`

```rust
pub struct ErrDef {
    pub status: u16,
    pub title: &'static str,
    pub code: &'static str,
    pub type_url: &'static str,
}

impl ErrDef {
    pub fn as_problem(&self, detail: impl Into<String>) -> Problem { ... }
}
```

#### `Problem` (RFC 9457)
**Location:** `libs/modkit-errors/src/problem.rs`

```rust
pub struct Problem {
    pub type_url: String,      // URI reference for problem type
    pub title: String,         // Human-readable summary
    pub status: StatusCode,    // HTTP status code
    pub detail: String,        // Specific occurrence explanation
    pub instance: String,      // URI for this occurrence
    pub code: String,          // Machine-readable error code
    pub trace_id: Option<String>,
    pub errors: Option<Vec<ValidationViolation>>,
}
```

**Builder Pattern:**
```rust
Problem::new(StatusCode::NOT_FOUND, "Not Found", "User not found")
    .with_code("gts.hx....")
    .with_type("https://...")
    .with_instance("/api/users/123")
    .with_trace_id("req-456")
    .with_errors(vec![...])
```

## Error Flow by Layer

### Layer 1: Domain Errors

Domain errors represent business logic failures. They are internal and don't contain HTTP-specific information.

**Location:** `<module>/src/domain/error.rs`

```rust
#[derive(Error, Debug)]
pub enum DomainError {
    #[error("User not found: {id}")]
    UserNotFound { id: Uuid },
    
    #[error("Email '{email}' already exists")]
    EmailAlreadyExists { email: String },
    
    #[error("Database error: {message}")]
    Database { message: String },
    // ...
}
```

### Layer 2: SDK Errors (Public API)

SDK errors are exposed to other modules via the client trait. They are simplified and safe to expose.

**Location:** `<module>-sdk/src/errors.rs`

```rust
#[derive(Error, Debug, Clone)]
pub enum UsersInfoError {
    #[error("Resource not found: {id}")]
    NotFound { id: Uuid },
    
    #[error("Validation error: {message}")]
    Validation { message: String },
    
    #[error("Internal error")]
    Internal,
}
```

### Layer 3: API Error Mapping

The API layer maps domain errors to RFC 9457 Problems using the error catalog.

**Location:** `<module>/src/api/rest/error.rs`

```rust
use crate::errors::ErrorCode;

pub fn domain_error_to_problem(e: &DomainError, instance: &str) -> Problem {
    let trace_id = tracing::Span::current()
        .id()
        .map(|id| id.into_u64().to_string());

    match &e {
        DomainError::UserNotFound { id } => {
            ErrorCode::example1_user_not_found_v1().with_context(
                format!("User with id {id} was not found"),
                instance,
                trace_id,
            )
        }
        DomainError::Database { .. } => {
            tracing::error!(error = ?e, "Database error occurred");
            ErrorCode::example1_user_internal_database_v1().with_context(
                "An internal database error occurred",
                instance,
                trace_id,
            )
        }
        // ...
    }
}
```

### Layer 4: HTTP Response

`Problem` implements `IntoResponse` for Axum, automatically:
- Setting the correct HTTP status code
- Setting `Content-Type: application/problem+json`
- Enriching with trace ID from current span if not set

```rust
// In handler
async fn get_user(...) -> Result<Json<User>, Problem> {
    let user = service.get_user(id).await
        .map_err(|e| domain_error_to_problem(&e, &path))?;
    Ok(Json(user))
}
```

## Creating a New Error Catalog

### Step 1: Create `gts/errors.json`

```json
[
  {
    "status": 404,
    "title": "Resource Not Found",
    "code": "gts.hx.core.errors.err.v1~hx.mymodule.resource.not_found.v1"
  },
  {
    "status": 422,
    "title": "Validation Error",
    "code": "gts.hx.core.errors.err.v1~hx.mymodule.validation.invalid_input.v1"
  }
]
```

### Step 2: Create `src/errors.rs`

```rust
use modkit_errors_macro::declare_errors;

declare_errors! {
    path = "gts/errors.json",
    namespace = "errors",
    vis = "pub"
}
```

### Step 3: Add to `Cargo.toml`

```toml
[dependencies]
modkit-errors-macro = { path = "../../libs/modkit-errors-macro" }
modkit-errors = { path = "../../libs/modkit-errors" }
```

### Step 4: Use in API Layer

```rust
use crate::errors::ErrorCode;

fn map_error(e: &MyDomainError, instance: &str) -> Problem {
    match e {
        MyDomainError::NotFound => {
            ErrorCode::mymodule_resource_not_found_v1()
                .with_context("Resource not found", instance, None)
        }
        // ...
    }
}
```

## Short Name Derivation

Short accessor names are derived from the final GTX segment:

```
gts.hx.core.errors.err.v1~hx.example1.user.not_found.v1
                         └─────────────────────────────┘
                                    ↓
                         example1_user_not_found_v1()
```

**Rules:**
1. Extract final GTX (after last `~`)
2. Drop vendor (first segment)
3. Join remaining segments with `_`
4. Prefix with `_` if starts with digit

**Override with `alias`:**
```json
{
  "code": "gts.hx.core.errors.err.v1~hx.example1.user.not_found.v1",
  "alias": "user_not_found"
}
```

## Existing Error Catalogs

| Module | Path | Description |
|--------|------|-------------|
| `users_info` (example) | `examples/modkit/users_info/users_info/gts/errors.json` | User management errors |
| `modkit-odata` | `libs/modkit-odata/gts/errors_odata.json` | OData query errors |

## Best Practices

1. **One catalog per module** - Keep errors scoped to their domain
2. **Use meaningful titles** - Titles appear in API responses
3. **Follow GTS format** - Enables global type identification
4. **Map at API boundary** - Domain layer should not know about HTTP
5. **Log internal errors** - Don't expose internal details to clients
6. **Include trace IDs** - Enables request tracing
7. **Use short accessors** - `ErrorCode::user_not_found_v1()` is cleaner than the full variant name

## JSON Response Format

```json
{
  "type": "https://errors.example.com/gts.hx.core.errors.err.v1~hx.example1.user.not_found.v1",
  "title": "User Not Found",
  "status": 404,
  "detail": "User with id 123e4567-e89b-12d3-a456-426614174000 was not found",
  "instance": "/api/user-management/v1/users/123e4567-e89b-12d3-a456-426614174000",
  "code": "gts.hx.core.errors.err.v1~hx.example1.user.not_found.v1",
  "trace_id": "1234567890"
}
```

## Related Files

- `libs/modkit-errors/` - Core error types (`Problem`, `ErrDef`)
- `libs/modkit-errors-macro/` - `declare_errors!` proc-macro
- `libs/modkit-odata/src/errors.rs` - OData error catalog usage
- `libs/modkit-odata/src/problem_mapping.rs` - OData error → Problem mapping
- `libs/modkit/src/api/odata/error.rs` - HTTP context enrichment
