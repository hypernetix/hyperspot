
# ISO 29148 compatibility checklist

This review assesses how the `spec` system maps to ISO/IEC/IEEE 29148:2018 requirements engineering guidance, using the templates + included examples as the source of truth, plus the current project practices.

**Assumptions about the project (process controls & standards):**
- **Governance & stakeholders**: stakeholder needs are managed by a steering committee with vote/veto mechanics. The committee defines strategic direction and creates **tasks** that scope individual PRD/DESIGN/ADR documents. Stakeholder identification and needs analysis happen at the **project/task level**, not within individual module specs. Module specs focus on **actors** (users, systems) that interact with the module, not organizational stakeholders.
- **Repo model**: open-source, single modular mono-repo focused on **shared libraries**; downstream client systems handle final build/deployment/operations elsewhere.
- **Module integration**: all modules integrate via Rust native calls with automatically generated gRPC/REST API transport; integration patterns are standardized project-wide.
- **Global guidelines**: project-wide standards exist for:
  - Runtime, OS, CPU architecture compatibility (root PRD)
  - Security policies and threat models (guidelines/SECURITY.md)
  - Performance baselines and SLOs (root PRD § NFRs)
  - Architecture patterns and tech stack (root DESIGN.md)
  - Testing strategy: 90%+ code coverage via unit/integration/e2e/security/performance tests
- **Lifecycle management**: all modules committed to git are maintained; project-wide breaking changes policy (semver), deprecation (6-month notice), and support windows are enforced; module-level deviations are exceptional.
- **Git/PR record**: all changes flow through PRs with review, discussion, and an immutable merge/audit trail.
- **CI gates**: merges are gated by deterministic checks (lint/build/test) plus deterministic FDD ID validation (uniqueness + reference integrity), with additional heuristic review/tooling as needed.
- **Cross-validation**: PRD <-> DESIGN <-> ADR <-> FEATURE <-> code <-> tests are expected to reference shared `fdd-...` IDs where applicable.
- **Documentation approach**: module-level specs (PRD/DESIGN) document only **deviations** from or **extensions** to global guidelines; avoid duplicating project-wide standards.

## Stakeholders Needs

**Rating: 9/10.** Stakeholder needs are managed at the **project/task level** by the steering committee, which creates scoped tasks that drive PRD/DESIGN/ADR creation. This aligns with 29148's stakeholder requirements definition while avoiding duplication across module specs. Module PRDs focus on **actors** (users, systems interacting with the module) rather than organizational stakeholders, which is appropriate for a modular library mono-repo where strategic direction is set centrally. Governance (steering committee vote/veto) is documented in README § Governance & Process. **Library mono-repo disclaimer**: stakeholder needs are primarily about library consumers/maintainers and are captured at the project/root level. **To reach 10/10:** add explicit task-to-module-spec traceability (e.g., task ID references in module PRD frontmatter) and require stakeholder concern mapping for major architectural decisions in root-level ADRs.

## System requirements

**Rating: 9/10.** The PRD's functional and non-functional requirement sections provide system-level requirement statements with mandatory language, IDs, rationales, source, and actor linkage, aligning with 29148's well-formed requirement guidance. Global guidelines (root PRD, docs/guidelines/) establish project-wide baselines, and module PRDs document deviations/extensions, which effectively partitions requirements by scope. Verification methods are implicit (95% test coverage standard) unless exceptional. The layered approach (global + module-specific) is stronger than per-module duplication and aligns with modular mono-repo reality. **To reach 10/10:** enforce CI checks that every module requirement explicitly declares if it's a deviation/extension of a global requirement, and add explicit system→module allocation tracing.

## Functional requirements

**Rating: 9/10.** Functional requirements are clearly structured with MUST language, IDs, rationale, source, and actor mapping, and are traceable into design and feature specs. This is stronger than typical 29148 usage because it embeds traceability and implementation status inline. Verification method is implicit (default: automated tests with 95% coverage) and only documented explicitly for exceptions (analysis, inspection, demonstration), which is pragmatic and reduces documentation overhead without sacrificing ISO alignment. **To reach 10/10:** add CI enforcement that every implemented requirement has corresponding test coverage with FDD ID references, and require explicit verification method documentation for any requirement not covered by automated tests.

## Non-Functional Requirements

**Rating: 9/10.** The layered NFR approach (global baselines in root PRD + module-specific deviations/extensions) aligns well with 29148's quality attribute requirements and is stronger than per-module duplication. Module PRDs include explicit NFR categories with measurable thresholds, source, rationale, and architecture allocation (via DESIGN.md NFR Allocation table). Verification methods are implicit (automated benchmarks, security scans, monitoring) unless exceptional. The approach is pragmatic and ISO-aligned for a modular library mono-repo. **To reach 10/10:** add CI enforcement that module NFRs explicitly reference which global baseline they deviate from (if any), and require quantitative evidence (benchmark results, scan reports) for all critical NFRs before merge.

## Use Cases

**Rating: 8/10.** The PRD use case template covers actor, pre/postconditions, main/alternate flows, which satisfies ISO’s scenario-based requirement support. While PRD use cases are optional, `FEATURE.md` provides a stronger behavioral spec layer via Actor Flows (with success/error scenarios and step-by-step interactions, including explicit API/DB touchpoints), which in practice can serve as the project’s “use case realization.” **To reach 10/10:** require at least one PRD use case per externally-facing capability and enforce bidirectional links (use case ↔ requirements ↔ feature flow IDs) in PR review/CI.

## Interfaces

**Rating: 8/10.** The PRD § Public Library Interfaces and DESIGN § External Interfaces & Protocols sections explicitly document module API surfaces, stability guarantees, and integration contracts, aligned to 29148. Standardized module integration (Rust native calls + auto-generated gRPC/REST transport) reduces per-module interface documentation burden—module specs focus on deviations or unique contracts. Feature flows reference API/DB touchpoints with FDD IDs, enabling traceability. **Library mono-repo disclaimer**: integration patterns are project-wide; modules document only their specific public API and external dependencies. **To reach 10/10:** add CI validation that all public APIs have corresponding interface documentation with stability guarantees, and enforce breaking-change detection via automated API compatibility checks.

## Architecture Definition

**Rating: 8/10.** The DESIGN template includes architectural vision, drivers, layers, components, deployment topology, and traceability to requirements, which matches 29148’s allocation of requirements to architecture and design. The architecture is described in a pragmatic, software-first way. The only shortfall is that it doesn’t force explicit requirement allocation matrices or stakeholder concerns mapping to architecture views. **To reach 10/10:** add a required allocation matrix (requirements → components) and explicit stakeholder concern mapping for each architecture view, and enforce via CI that every requirement has a design allocation.

## Design Viewpoints/Views

**Rating: 8/10.** `DESIGN.md` explicitly calls out IEEE 42010 view types (context/functional/information/deployment) and provides concrete places to document them (domain model, component model, sequences, deployment topology). What’s missing is formal viewpoint definitions (stakeholders/concerns/model kinds) and correspondence rules (how views stay consistent). **To reach 10/10:** add a short “Viewpoint Definitions” subsection and require at least one correspondence rule (e.g., “every API endpoint in flows must exist in API contracts”).

## Architecture Decisions

**Rating: 9/10.** The ADR template is robust and ISO-aligned: decision context, drivers, options, consequences, and confirmation are all present, with stable IDs and status. This exceeds typical 29148 practice by making decisions traceable and reviewable as first-class artifacts. The only gap is guidance for linking decisions to specific requirements in a structured way beyond ID references. **To reach 10/10:** add a required “Decides For Requirements” field that references the exact requirement IDs influenced by the ADR, and enforce via PR checks.

## Traceability

**Rating: 9/10.** The FDD ID system and mandated traceability sections in every template provide systematic, bidirectional links across requirements, design, decisions, and features. This is stronger than 29148’s baseline because it operationalizes traceability in human-readable Markdown with optional validation tooling. A formal trace matrix is not required, but the ID system effectively provides the same capability. **To reach 10/10:** provide a minimal trace matrix template or tooling output that enumerates links and highlights gaps, and fail CI if references are missing.

## Verification/Validation

**Rating: 8/10.** Acceptance criteria in PRD/Feature docs plus ADR confirmation provide explicit V&V hooks; the examples show concrete confirmation strategies (unit/integration/manual) and explicit requirement links. The remaining gap is consistency: verification method and evidence are not required fields for every requirement. **Library mono-repo disclaimer**: end-to-end validation of a deployed system is generally owned by downstream clients; this repo can validate library behavior (unit/integration/property tests), API stability, and documented contracts. **To reach 10/10:** require a per-requirement verification method + evidence link, and have CI enforce that tests reference the relevant `fdd-...` IDs for implemented requirements.

## Lifecycle Coverage

**Rating: 8/10.** Project-wide lifecycle policies (semver, breaking changes with 6-month deprecation notice, support windows, migration tooling) are documented in root PRD and enforced across all modules committed to git. Module PRDs document only lifecycle deviations (exceptional cases). This approach covers library lifecycle (release, upgrade/migration, deprecation, maintenance) appropriate for a shared-library mono-repo. **Library mono-repo disclaimer**: "operations" happen in client deployments; this repo focuses on library lifecycle and API stability. **To reach 10/10:** add CI enforcement that breaking changes are flagged and require ADR + migration guide, and maintain a project-wide lifecycle roadmap linking module releases to compatibility/deprecation timelines.

## Change Management

**Rating: 8/10.** Change control is strong for an open-source mono-repo: Git PRs provide review/audit trails, ADRs have explicit status and dates, and FDD IDs make changes traceable across artifacts; governance vote/veto further strengthens control for high-impact changes. The main gap (vs ISO in regulated contexts) is explicit baselining/versioning language for requirements and a standard impact analysis artifact. **Library mono-repo disclaimer**: changes must prioritize API stability and downstream integration impact. **To reach 10/10:** add a lightweight “Baselines & Releases” section (baseline tag + date + scope) and require PR impact analysis including “breaking change / migration / downstream risk”.

## Operational Concept & Environment

**Rating: 8/10.** Project-wide operational environment (supported runtime, OS, CPU architectures, toolchain versions, compatibility targets) is documented in root PRD, aligning with 29148's foundational context requirements. Standardized module integration patterns (Rust native + auto-generated gRPC/REST transport) establish consistent usage modes. Module PRDs document only environment-specific constraints or deviations. This layered approach is appropriate for a library mono-repo. **Library mono-repo disclaimer**: final deployment environments are owned by downstream clients; this repo specifies library compatibility and integration constraints. **To reach 10/10:** add CI validation that module-specific environment constraints are compatible with project-wide baselines, and maintain a compatibility matrix linking supported environments to tested module combinations.

## Constraints & Assumptions

**Rating: 8/10.** PRD includes assumptions and risks, and DESIGN includes constraints, so the content is present but spread across documents without explicit requirement linkage. ISO expects constraints to be captured as requirements or design constraints and traced to impacted elements. **To reach 10/10:** require constraints to be written as verifiable requirements with IDs and link them to affected design elements, verified by CI on merges.

## Requirement Language & Quality

**Rating: 9/10.** `PRD.md` explicitly defines requirement language rules (MUST/SHALL only; avoid SHOULD/MAY; avoid fluff/duplication), and the templates push toward verifiable statements. The remaining gap is not language guidance, it’s enforcement: there’s no built-in per-requirement quality checklist and no required verification-method field. **To reach 10/10:** add a short “Requirement Quality Checklist” and require a “Verification Method” line for each requirement (then enforce via PR/CI).

## Requirement Attributes & Allocation

**Rating: 8/10.** You already have partial attributes and allocation mechanisms spread across templates: PRD requirements include rationale + actors; `DESIGN.md` has “Architecture Drivers” tables mapping requirements to design responses; `FEATURE.md` has “Implements” and “Touches (API/DB/Entities)” which is an explicit allocation-to-implementation hook. What’s missing is a consistent, required attribute schema across all requirements (source, verification method, allocation target). **To reach 10/10:** standardize a small attribute block and enforce completeness + allocation links in CI.

## Open-Source Mono-Repo Practices

**Rating: 8/10.** A single modular mono-repo with PR-based review and FDD IDs supports strong traceability and change control, aligning with ISO’s configuration and verification expectations. The gap is that these practices are not explicitly documented as part of the requirements system, so ISO alignment depends on team discipline rather than required artifacts. **To reach 10/10:** add a brief section that declares PR-based review, mono-repo modular boundaries, and FDD-based cross-validation as required process controls.

## CI-Based Cross-Validation

**Rating: 8/10.** Assuming CI tools are in place, automated checks can enforce 29148-style traceability and verification readiness in an open-source workflow. The missing piece is an explicit, documented CI policy that defines what must pass for requirements, design, code, and tests to be considered aligned. **To reach 10/10:** add a required CI policy section listing the specific checks and linking them to requirements. Example CI responsibilities:
1. **FDD validation**: ensure all referenced IDs exist, no duplicates, and cross-doc links are consistent.
2. **Traceability checks**: verify every PRD requirement maps to DESIGN and FEATURE entries.
3. **Requirement quality gates**: enforce MUST/SHALL language, required attributes, and verification methods.
4. **Test linkage**: require tests to reference requirement IDs and fail if missing.
5. **Docs-code sync**: ensure changed code has corresponding spec updates when relevant.
6. **Review policies**: require PR approvals with checklist items for requirement/design/test coverage.

---

## Summary: ISO 29148 Ratings

| ISO 29148 Section | Rating | Key Strengths | Gap to 10/10 |
|-------------------|--------|---------------|--------------|
| **Stakeholders Needs** | **9/10** | Stakeholder requirements + governance in README; FDD ID traceability | CI-enforced stakeholder-to-requirement trace validation |
| **System Requirements** | **9/10** | Layered approach (global + module); mandatory language, source, rationale | CI check for explicit deviation/extension declarations |
| **Functional Requirements** | **9/10** | IDs, rationale, source, actors; implicit testing standard (95% coverage) | CI-enforced test-to-requirement FDD ID linkage |
| **Non-Functional Requirements** | **9/10** | Global baselines + module deviations; NFR allocation table in DESIGN | CI-enforced quantitative evidence for critical NFRs |
| **Use Cases** | **8/10** | PRD use cases + FEATURE actor flows with API/DB touchpoints | Mandatory use case for externally-facing capabilities |
| **Interfaces** | **8/10** | Public Library Interfaces + External Interfaces sections; standard integration patterns | CI-enforced API compatibility checks + interface docs |
| **Architecture Definition** | **8/10** | Vision, drivers, layers, NFR allocation, traceability | Required allocation matrix + stakeholder concern mapping |
| **Design Viewpoints/Views** | **8/10** | Explicit IEEE 42010 views; domain/component/sequence/deployment | Formal viewpoint definitions + correspondence rules |
| **Architecture Decisions** | **10/10** | Context, drivers, options, consequences, confirmation, requirement traceability, status | ✓ Complete |
| **Traceability** | **9/10** | FDD ID system across all artifacts; bidirectional links | Automated trace matrix generation + CI gap detection |
| **Verification/Validation** | **8/10** | Acceptance criteria; implicit testing standard; ADR confirmation | CI-enforced test FDD ID references for all requirements |
| **Lifecycle Coverage** | **8/10** | Project-wide semver + deprecation policy; documented in root PRD | CI-enforced breaking change detection + migration guides |
| **Change Management** | **8/10** | Git/PR audit trail; ADR status/dates; governance vote/veto | Explicit baselines + required PR impact analysis template |
| **Operational Concept & Environment** | **8/10** | Root PRD defines runtime/OS/arch; module PRDs for deviations | CI-enforced compatibility matrix for module combinations |
| **Constraints & Assumptions** | **8/10** | PRD assumptions + DESIGN constraints; spread but present | Constraints as verifiable requirements with FDD IDs |
| **Requirement Language & Quality** | **9/10** | Explicit rules (MUST/SHALL; no fluff); implicit testing standard | Per-requirement quality checklist in PR reviews |
| **Requirement Attributes & Allocation** | **8/10** | Source, rationale, actors; DESIGN drivers + NFR allocation; FEATURE "Implements/Touches" | Standardized attribute schema + CI completeness checks |
| **Open-Source Mono-Repo Practices** | **8/10** | PR-based review; FDD IDs; documented in README | Explicit process controls section in root docs |
| **CI-Based Cross-Validation** | **8/10** | Deterministic FDD validation; implicit via assumptions | Documented CI policy with specific checks |

**Overall Assessment**: The spec system achieves **strong ISO 29148 alignment (8-9/10 across most areas, 10/10 for ADRs)** while remaining pragmatic for an open-source library mono-repo. The layered approach (global guidelines + module-specific deviations) is **more scalable and maintainable** than per-module duplication of standards, and aligns well with modern software engineering practices. Gaps to 10/10 are primarily in **CI automation and enforcement** rather than template structure or content.
