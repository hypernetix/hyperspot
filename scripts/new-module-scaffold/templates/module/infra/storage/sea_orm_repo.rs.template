//! SeaORM-backed repository implementation for the domain port.
//!
//! Uses `SecureConn` to automatically enforce security scoping on all database operations.
//! All queries are filtered by the security context provided at the request level.
//!
//! # Type-Safe `OData` Implementation
//!
//! This module demonstrates the complete type-safe `OData` approach:
//! - Uses generated `UserDtoFilterField` enum for all field references
//! - No string-based field names anywhere
//! - No exposure of `SeaORM` Column types to API/domain layers
//! - All filtering, ordering, and cursor extraction is type-safe

use anyhow::Context;
use tracing::{{debug, instrument}};
use uuid::Uuid;

use crate::api::rest::dto::ExampleDtoFilterField;
use crate::domain::repo::ExampleRepository;
use crate::infra::storage::entities::example_entity::Entity as ExampleEntity;
use crate::infra::storage::odata_mapper::ExampleODataMapper;
use modkit_db::odata::{{paginate_odata, LimitCfg}};
use modkit_db::secure::SecureConn;
use modkit_odata::{{ODataQuery, Page, SortDir}};
use modkit_security::AccessScope;
use {snake}_sdk::Example;

/// `SeaORM` repository implementation with automatic security scoping.
///
/// This repository uses `SecureConn` to ensure all database operations
/// respect the security context provided by the caller. Queries are automatically
/// filtered based on tenant/resource access rules.
///
/// # Security Model
///
/// The users table is tenant-scoped via the `tenant_id` column:
/// - **Tenant isolation**: Users are automatically filtered by `tenant_id` from the security context
/// - **Email uniqueness**: Email addresses must be unique within a tenant (not globally)
/// - **Deny-by-default**: Empty security context denies all access
pub struct SeaOrmUsersRepository {{
    sec: SecureConn,
}}

impl SeaOrmUsersRepository {{
    /// Create a new repository with a secure database connection.
    #[must_use]
    pub fn new(sec: SecureConn) -> Self {{
        Self {{ sec }}
    }}
}}

#[async_trait::async_trait]
impl ExampleRepository for SeaOrmUsersRepository {{
    #[instrument(
        skip(self, scope),
        fields(
            db.system = %self.sec.db_engine(),
            db.operation = "SELECT",
            user.id = %id
        )
    )]
    async fn find_by_id(&self, scope: &AccessScope, id: Uuid) -> anyhow::Result<Option<Example>> {{
        debug!("Finding user by id with security context");

        let found = self
            .sec
            .find_by_id::<ExampleEntity>(scope, id)
            .context("Failed to create secure query")?
            .one(self.sec.conn())
            .await
            .context("find_by_id query failed")?;
        Ok(found.map(Into::into))
    }}

        #[instrument(
        skip(self, scope, query),
        fields(
            db.system = %self.sec.db_engine(),
            db.operation = "SELECT"
        )
    )]
    async fn list_page(
        &self,
        scope: &AccessScope,
        query: &ODataQuery,
    ) -> Result<Page<Example>, modkit_odata::Error> {{
        debug!("Listing users with fully type-safe OData");

        // Apply security scope first
        let secure_query = self.sec.find::<ExampleEntity>(scope);
        let base_query = secure_query.into_inner();

        // Use the new type-safe pagination - it handles filters, ordering, and cursors
        paginate_odata::<ExampleDtoFilterField, ExampleODataMapper, _, _, _, _>(
            base_query,
            self.sec.conn(),
            query,
            ("id", SortDir::Desc), // Default tiebreaker
            LimitCfg {{
                default: 25,
                max: 1000,
            }},
            Into::into,
        )
        .await
    }}
}}
